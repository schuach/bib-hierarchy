#+TITLE: Anzeige von Hierarchien aus (nicht in) Alma
#+NIKOLA_SLUG: alma-hierarchy
#+AUTHOR: Stefan Schuh
#+EMAIL: stefan.schuh@uni-graz.at
#+DATE: 2018-08-03 12:01
#+DESCRIPTION:
#+KEYWORDS:
#+OPTIONS: H:4 num:nil toc:nil ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: tex:t todo:t pri:nil tags:t texht:nil
#+OPTIONS: author:nil creator:nil email:nil date:t
#+MACRO: teaser #+RST: .. TEASER_END
#+EXPORT_FILE_NAME: ../posts/alma-hierarchy.rst

* Ausgangsituation und Zweck dieses Programmes
  In Alma ist die Anzeige von Hierarchien nicht gut möglich. Die Daten sind
  aber da. Daher sollte es ja möglich sein, diese per SRU abzufragen und zu
  sortieren.
  
* Skript
*** Imports etc.
    #+NAME: imports
    #+BEGIN_SRC python
    import requests
    import urllib.parse
    import io
    import pymarc
    import xml.etree.ElementTree as ET
    import sys
    import natsort
    import os
    import easygui
    #+END_SRC

    Außer den Imports brauchen wir noch ein paar globale Variablen:

    #+NAME: globals
    #+BEGIN_SRC python
      # Namespaces fürs xml
      ns = {'marc': 'http://www.loc.gov/MARC21/slim', 'srw': 'http://www.loc.gov/zing/srw/'}
      # Template für MARC-XML
      marc_template = """<marc:collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xsi:schemaLocation="http://www.loc.gov/MARC21/slim http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd"/>"""

      institution_code = "43ACC_UBG"
      # get the network number from the user
      if len(sys.argv) == 1:
          out_format = "gui"
          acnr = get_user_input()
      elif len(sys.argv) == 2:
          if sys.argv[1].startswith("AC"):
              out_format = "stdo"
              acnr = sys.argv[1]
          else:
              out_format = sys.argv[1]
              acnr = get_user_input()
      else:
          acnr = sys.argv[1]
          out_format = sys.argv[2]
    #+END_SRC

    Einige Variablen kann man über Kommandozeilenargumente setzen:
    1. AC-Nummer des Kopfsatzes (optional)
    
    Um die AC-Nummer von der Benutzerin zu erfragen, verwenden wir easygui.
    Damit wir gleich checken können, ob die AC-Nummer eine AC-Nummer ist,
    definieren wir eine Funktion, die sich den Input holt, und diesen Prüft.
    Wenn die Prüfung negativ ausfällt, geht es wieder von vorne los.
    
    #+NAME: get user input
    #+BEGIN_SRC python
      def get_user_input():
          title = "ALMA Hierarchieabfrage"
          msg = "Bitte die AC-Nummer des Kopfsatzes eingeben."

          while True:
              acnr = easygui.enterbox(msg, title)

              if acnr is None:
                  quit()
              elif acnr.startswith("AC") and len(acnr) == 10:
                  return acnr
              elif acrn == None:
                  break
              else:
                  contiue
    #+END_SRC

*** Abfrage per SRU
    Wenn man die AC-Nummer des Kopfsatzes einer Hierarchie weiß, ist es recht
    einfach, alle Datensätze zu bekommen (sofern es nicht sehr viele sind). Dazu
    definieren wir eine Funktion, die die AC-Nummer des Kopfes entgegennimmt und
    eine Liste der response-Texte zurückgibt:

    #+NAME: SRU-request
    #+BEGIN_SRC python
      def get_records(acnr):
          """Get all records containing acnr and return a list of responses (strings)"""
          response_list = []
          offset = 1
          # sru_request = "https://obv-at-ubg.alma.exlibrisgroup.com/view/sru/43ACC_UBG?version=1.2&operation=searchRetrieve&recordSchema=marcxml&query=other_system_number={acnr}&startRecord={offset}&maximumRecords=50"
          sru_request = "https://obv-at-obvsg.alma.exlibrisgroup.com/view/sru/43ACC_NETWORK?version=1.2&operation=searchRetrieve&recordSchema=marcxml&query=other_system_number={acnr}&startRecord={offset}&maximumRecords=50"

          # get the first 50 records
          print("Hole Daten von Alma ...")
          res = requests.get(sru_request.format(acnr=acnr, offset=offset))
          # append the response to the list
          response_list.append(res.text)

          # check how many records there are
          res_xml = ET.fromstring(res.text)
          numberOfRecords = int(res_xml.find("srw:numberOfRecords", ns).text)

          if numberOfRecords == 0:
              print("Keine Datensätze gefunden")
              quit()

          # repeat the request with increasing offset to get all records
          while offset < numberOfRecords - 50:
              offset += 50
              print(f"Mehr Datensätze vorhanden. Hole {offset}-{offset + 50} von {numberOfRecords}")
              res = requests.get(sru_request.format(acnr=acnr, offset=offset))
              response_list.append(res.text)

          return response_list
     #+END_SRC

     Danach holen wir uns aus der Liste der API-Responses eine Liste der
     MARC-Records als pymarc.Record-Objekte:
     #+NAME: populate record list
     #+BEGIN_SRC python
       def populate_reclist(response_list):
           """Populate a list with the records containing acnr."""

           reclist = []
           marc_xml = ET.fromstring(marc_template)

           # append all the marc-records in the responses to marc_xml
           for response in response_list:
               res_xml = ET.fromstring(response)
               for record in res_xml.findall('.//marc:record', ns):
                   marc_xml.append(record)

           # convert xml element to file-like-object, so pymarc can parse it
           marcfile = io.StringIO(ET.tostring(marc_xml, encoding="unicode"))

           # parse the xml to a pymarc.Reader
           with marcfile as marcfile:
               reader = pymarc.parse_xml_to_array(marcfile)

           for record in reader:
               reclist.append(record)

           return reclist
     #+END_SRC

     Jetzt wo wir eine Liste unserer Datensätze haben, bauen wir eine
     Datenstruktur auf, aus der wir unsere Hierarchie ableiten können.

*** Die Hierarchie

    Wir modellieren die Hierarchie in Python als =dict= mit folgender Struktur:

    #+BEGIN_SRC ditaa :file docs/pic/struct.png

      +---------------------------------------------------------------+
      |                                                               |
      |  hierarchy (dict)                                             |
      |                                                               |
      |  +---------------------------------------------------------+  |
      |  |                                                         |  |
      |  |      cPNK  head (pymarc.Record)                         |  |
      |  |                                                         |  |
      |  +---------------------------------------------------------+  |
      |                                                               |
      |                                                               |
      |  +---------------------------------------------------------+  |
      |  |                                                         |  |
      |  |   deps (dict)              cGRE                         |  |
      |  |                                                         |  |
      |  |  +---------------------------------------------------+  |  |
      |  |  |                                                   |  |  |
      |  |  | key (AC-Nummer)  (pymarc.Record)   cBLU           |  |  |
      |  |  |                                                   |  |  |
      |  |  +---------------------------------------------------+  |  |
      |  |                                                         |  |
      |  |  +---------------------------------------------------+  |  |
      |  |  |                                                   |  |  |
      |  |  | key (AC-Nummer)  (pymarc.Record)   cBLU           |  |  |
      |  |  |                                                   |  |  |
      |  |  +---------------------------------------------------+  |  |
      |  |                                                         |  |
      |  |  +---------------------------------------------------+  |  |
      |  |  |                                                   |  |  |
      |  |  | key (AC-Nummer)  (pymarc.Record)   cBLU           |  |  |
      |  |  |                                                   |  |  |
      |  |  +---------------------------------------------------+  |  |
      |  |                                                         |  |
      |  |   ...                                                   |  |
      |  |                                                         |  |
      |  |                                                         |  |
      |  +---------------------------------------------------------+  |
      |                                                               |
      |  +---------------------------------------------------------+  |
      |  |                                                         |  |
      |  |   order (dict)                                          |  |
      |  |                                                         |  |
      |  |   +--------------------------------------------------+  |  |
      |  |   |                                                  |  |  |
      |  |   |  key (Sortierform) [AC-Nummer, AC-Nummer, ...]   |  |  |
      |  |   |                                                  |  |  |
      |  |   +--------------------------------------------------+  |  |
      |  |                                                         |  |
      |  |   +--------------------------------------------------+  |  |
      |  |   |                                                  |  |  |
      |  |   |  key (Sortierform) [AC-Nummer, AC-Nummer, ...]   |  |  |
      |  |   |                                                  |  |  |
      |  |   +--------------------------------------------------+  |  |
      |  |                                                         |  |
      |  |   ...                                                   |  |
      |  |                                                         |  |
      |  +---------------------------------------------------------+  |
      |                                                               |
      +---------------------------------------------------------------+
    #+END_SRC

    #+RESULTS:
    [[file:docs/pic/struct.png]]
    
    Im dict gibt es einen key namens =head=. Dieser enthält als Wert den
    pymarc.Record des Kopfsatzes.

    Unter dem key =deps= finden sich wieder ein dict, mit einem key pro
    abhängigem Datensatz. Der Key des jeweiligen Datensatzes ist seine
    AC-Nummer, der Wert der entsprechende pymarc.Record.

    =order= ist auch ein dict, in dem die keys die jeweiligen Sortierformen
    sind, sodass wir mit 

    #+BEGIN_SRC python
    natsort.natsorted(hierarchy["order"].keys())
    #+END_SRC

    eine Liste bekommen, die richtig sortiert ist. Jeder dieser keys hat als
    Wert eine Liste der AC-Nummern, die wiederum die keys in =hierarchy["deps"]=
    für die entsprechenden Datensätze sind. D. h. man kann mit folgendem
    Konstrukt über alle abhängigen Datensätze in der richtigen Reihenfolge
    iterieren:

    #+BEGIN_SRC python
      # geordnete Liste der Sortierformen(=keys in hierarchy["order"]) herstellen
      order = natsort.natsorted(hierarchy["order"].keys())
      # über alle Datensätze in der richtigen Reihenfolge iterieren
      for keylist in order:
          for key in hierarchy["order"][keylist]:
          [...]
    #+END_SRC



    #+NAME: build_hierarchy
    #+BEGIN_SRC python
      def build_hierarchy(record_list):
          hierarchy = {"head": None, "deps": {}, "order": {}}

          for rec in record_list:
              field_009 = rec["009"].value().strip()
              if field_009 == acnr:
                  hierarchy["head"] = rec
              else:
                  hierarchy["deps"][field_009] = rec
                  for field in rec.get_fields("773"):
                      if not acnr in field.value():
                          continue
                      else:
                          if field["q"] == None:
                              field.add_subfield("q", "ZZZ - Keine Sortieform vorhanden")
                          if not field["q"] in hierarchy["order"]:
                              hierarchy["order"][field["q"]] = [field_009]
                          else:
                              hierarchy["order"][field["q"]].append(field_009)

                  for field in rec.get_fields("830"):
                      if not acnr in field.value():
                          continue
                      else:
                          if field["v"] == None:
                              field.add_subfield("v", "ZZZ - Keine Sortieform vorhanden")
                          if not field["v"] in hierarchy["order"]:
                              hierarchy["order"][field["v"]] = [field_009]
                          else:
                              hierarchy["order"][field["v"]].append(field_009)

          return hierarchy
    #+END_SRC
    

*** TODO Ausgabe
    Die Ausgabe erfolgt vorerst noch auf die Konsole, könnte aber auch in eine
    Texdatei oder, wahrscheinlich noch besser, in ein HTML-Dokument erfolgen.
***** Helferfunktionen
      Wir definieren Hilfsfunktionen, die prüfen, ob es sich um TUTs oder TATs
      handelt, wir lokalen Bestand haben, etc.

      #+NAME: checkers
      #+BEGIN_SRC python
        def check_rectype(record):
            """Check if a record is a TAT or a TUT and return corresponding string."""

            if record.leader[19] == "c":
                rectype = "TAT"
            elif record.leader[19] == "b":
                rectype = "TUT"
            # TODO check for MTM
            else:
                rectype = None

            return rectype

        def check_holdings(record, institution_code):
            "Return true, if institution has holdings for the record"

            holdings = False
            for field in record.get_fields("852"):
                if institution_code in field["a"]:
                    holdings = True
                else:
                    continue

            return holdings
      #+END_SRC

***** Den String aufbauen

      #+NAME: hierarchy_to_string
      #+BEGIN_SRC python
        def hierarchy_to_string(hierarchy):
            """Return a string with a representation of the hierarchy."""
            s = hierarchy["head"]["245"].value() + "\n"
            s += f"    {len(hierarchy['deps'])} abhängige Datensätze\n"

            # make list of sorted keys for hierarchy["order"]
            order = natsort.natsorted(hierarchy["order"].keys())

            # iterate over all dependent records in the right order
            for keylist in order:
                # print(keylist)
                for key in hierarchy["order"][keylist]:
                    rec = hierarchy["deps"][key]
                    tut_prefix = "    |===> "
                    tat_prefix = "    |---> "
                    general_prefix = "    |     "
                    # checken if in IZ
                    for field in rec.get_fields("852"):
                        if check_holdings(rec, institution_code) is True:
                            tut_prefix = "*   |===> "
                            tat_prefix = "*   |---> "
                            general_prefix = "    |     "

                    if check_rectype(rec) == "TAT":
                        title = rec["245"].subfields
                        subfields = []
                        sf_to_delete = ["a", "b", "c"]

                        # get rid of $$b and $$c
                        for code in sf_to_delete:
                            if code in title:
                                index = title.index(code)
                                # once for the code
                                del title[index]
                                # and for the value
                                del title[index]

                        for subfield in title[1:]:
                            if subfield == "n":
                                subfields.append(". ")
                            elif subfield == "p":
                                subfields.append(", ")
                            else:
                                subfields.append(subfield)

                        titlestring = tat_prefix + "".join(subfields)
                    else:
                        title = rec["245"].subfields
                        subfields = []

                        for subfield in title:
                            if subfield == "a":
                                continue
                            elif subfield == "b":
                                subfields.append(" : ")
                            elif subfield == "c":
                                subfields.append(" / ")
                            else:
                                subfields.append(subfield)

                        titlestring = tut_prefix + keylist + ": " + "".join(subfields)

                    s += titlestring + "\n"
                    if rec["250"]:
                        s += general_prefix + f'    Auflage: {rec["250"]["a"]}\n'
                    if rec["264"]:
                        if rec["264"]["c"]:
                            s += general_prefix + f'    Erscheinungsdatum: {hierarchy["deps"][key]["264"]["c"]}\n'
                    else:
                        s += f'    Erscheinungsdatum unbekannt\n'
                    s += general_prefix + f'    AC-Nummer: {key}\n'

            return s
      #+END_SRC
*** Alles zusammen
    #+BEGIN_SRC python :noweb yes :tangle alma-hierarchy/alma-hierarchy.py
      <<imports>>
      <<get user input>>
      <<globals>>
      <<SRU-request>>
      <<populate record list>>
      <<build_hierarchy>>
      <<checkers>>
      <<hierarchy_to_string>>

      response_list = get_records(acnr)
      record_list = populate_reclist(response_list)
      hierarchy = build_hierarchy(record_list)
      if out_format == "stdo":
          print(hierarchy_to_string(hierarchy))
      else:
          easygui.codebox(text=hierarchy_to_string(hierarchy))
    #+END_SRC
*** Tests
***** Beispieldatensätze
      | AC03249772 | Buber Werkausgabe                           |
      | AC00006553 | Heidegger Gesamtausgabe                     |
      | AC13448176 | Geschichte der Homosexuellen in Deutschland |
      |            |                                             |
